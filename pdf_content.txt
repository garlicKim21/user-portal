프로젝트 개요: OIDC와 동적 Pod를 이용한 쿠버네티스 웹 콘솔
포털
이 프로젝트의 목표는 사용자가 웹 포털을 통해 인증하고, 버튼 클릭 한 번으로 자신만의
격리된 웹 기반 쿠버네티스 CLI(kubectl) 환경을 동적으로 제공받는 시스템을 구축하는
것입니다.

1. 시스템 아키텍처
본 시스템은 두 개의 쿠버네티스 클러스터와 외부 인증 시스템으로 구성됩니다.
●​ 서비스 클러스터 (A 클러스터):
○​ 사용자에게 직접 서비스를 제공하는 Public Facing 클러스터입니다.
○​ Keycloak (IdP): OIDC 기반 인증 서버. OpenLDAP과 연동됩니다.
○​ 포털 애플리케이션 (Go): 사용자가 접속하는 웹 포털. 이 애플리케이션이 웹 콘솔

Pod를 동적으로 생성하고 관리합니다.
○​ OPNsense 방화벽: 외부 인터넷과 클러스터를 연결하며, Nginx 플러그인을 통해
리버스 프록시 및 TLS 터미네이션을 담당합니다.
●​ 제어 대상 클러스터 (B 클러스터):
○​ 사용자가 웹 콘솔을 통해 실제로 제어하게 될 타겟 클러스터입니다.
○​ API 서버는 A 클러스터의 Keycloak을 OIDC 인증 제공자로 신뢰하도록
설정됩니다.
●​ 인증 소스:
○​ OpenLDAP: 모든 사용자와 그룹 정보의 원천 소스(Source of Truth)입니다.
(AI 주: 위 링크는 예시이며, 실제 다이어그램이 있다면 해당 링크로 대체하십시오.)

2. 사용자 흐름 (User Flow)
1.​ 사용자는 웹 브라우저로 https://portal.basphere.dev에 접속합니다.
2.​ "Login" 버튼을 클릭하면, Keycloak 로그인 페이지로 리디렉션됩니다.
3.​ 사용자는 자신의 LDAP 계정(예: testuser)으로 로그인합니다.
4.​ 인증에 성공하면, 다시 포털 페이지로 돌아옵니다. 이때 화면에는 로그인한 사용자의

이름과 "Launch Web Console" 버튼이 표시됩니다.
5.​ 사용자가 "Launch Web Console" 버튼을 클릭합니다.
6.​ 잠시 후 새 브라우저 탭이 열리며, 웹 기반 터미널이 나타납니다.
7.​ 사용자는 이 터미널에서 별도의 로그인 없이 바로 kubectl get pods와 같은 명령어를
사용하여 B 클러스터의 리소스를 제어할 수 있습니다.

3. 핵심 로직 구현 (Backend - Go)
백엔드는 Go 언어와 Gin 프레임워크를 사용하여 구현합니다.

●​ /api/login (GET):
○​ OIDC 인증 코드 플로우(Authorization Code Flow)를 시작합니다.
○​ coreos/go-oidc 라이브러리를 사용하여 Keycloak 인증 URL을 생성하고,

사용자를 해당 URL로 리디렉션시킵니다.
●​ /api/callback (GET):
○​ Keycloak에서 리디렉션된 요청을 처리합니다.
○​ URL 쿼리 파라미터로 받은 authorization_code를 사용하여 Keycloak에 토큰을
요청합니다.
○​ coreos/go-oidc 및 golang.org/x/oauth2 라이브러리를 사용합니다.
○​ 발급받은 access_token, id_token, refresh_token을 서버 측 세션에 안전하게
저장합니다.
○​ 사용자를 포털 메인 페이지로 리디렉션시킵니다.
●​ /api/launch-console (GET):
○​ 1. kubeconfig 동적 생성:
■​ 현재 사용자의 세션에서 id_token을 가져옵니다.
■​ 이 토큰을 사용하여 B 클러스터에 접근하기 위한 kubeconfig 내용을
문자열로 생성합니다. kubeconfig의 user 섹션은 OIDC 인증 제공자 설정을
포함해야 합니다.
○​ 2. A 클러스터에 리소스 생성:
■​ k8s.io/client-go 라이브러리를 사용하여 A 클러스터의 API 서버와
통신합니다.
■​ 생성한 kubeconfig 내용을 담은 ConfigMap을 생성합니다.
■​ 웹 터미널(ttyd)과 kubectl이 설치된 컨테이너 이미지를 사용하여 Pod를
생성합니다.
■​ 이때, 방금 생성한 ConfigMap을 Pod 내부의 /home/user/.kube/config
경로에 볼륨으로 마운트합니다.
■​ 생성된 Pod를 외부로 노출시키기 위한 Service와 Ingress 리소스를 동적으로
생성합니다. (예: console-testuser.basphere.dev)
○​ 3. URL 반환:
■​ 생성된 Ingress의 URL을 JSON 형태로 클라이언트에게 반환합니다.

4. 프론트엔드 (Vite + Vanilla JS)
●​ index.html: "Login", "Launch Web Console" 버튼과 사용자 정보를 표시할 div

영역을 포함합니다.
●​ main.js:
○​ "Login" 버튼 클릭 시, 백엔드의 /api/login 엔드포인트를 호출합니다.
(window.location.href)
○​ "Launch Web Console" 버튼 클릭 시, 백엔드의 /api/launch-console
엔드포인트를 fetch로 호출하고, 응답으로 받은 URL을 window.open()을 통해 새

탭에서 엽니다.
○​ 페이지 로드 시, 백엔드에 사용자 정보를 요청하여 로그인 상태를 확인하고 UI를
업데이트합니다.

5. 개발 환경 및 목표
●​ 개발 환경: M1 Mac (ARM64)
●​ 배포 환경: AMD64 아키텍처의 쿠버네티스 클러스터
●​ 요구사항: Docker 이미지 빌드 시 docker buildx --platform linux/amd64를 사용하여

크로스 플랫폼 빌드가 필수적입니다.

AI에 대한 요청 (Task for AI)
안녕하세요. 위에 설명된 프로젝트의 백엔드 로직을 Go 언어로 구현하는 것을
도와주세요.
1.​ Gin 프레임워크를 사용하여 기본 웹 서버와 /api/login, /api/callback,

/api/launch-console 세 개의 API 엔드포인트 스켈레톤 코드를
작성해주세요.
2.​ /api/login과 /api/callback 함수 내부에 coreos/go-oidc 라이브러리를
사용하여 Keycloak OIDC 인증 코드 플로우를 처리하는 로직을
구현해주세요.
3.​ /api/launch-console 함수 내부에 k8s.io/client-go 라이브러리를
사용하여 ConfigMap과 Pod를 동적으로 생성하는 로직의 예시를
보여주세요.

