# **AI 코딩 에이전트 작업 명세서: User Portal 아키텍처 리팩토링**

### **1\. 프로젝트 목표**

본 프로젝트의 목표는 기존 **백엔드 중심의 인증 아키텍처**를 **프론트엔드 중심의 OIDC 인증 아키텍처**로 전환하는 것입니다.

portal-backend는 더 이상 자체적인 사용자 인증 및 세션 관리를 수행하지 않으며, **Kubernetes 리소스 관리에만 집중하는 순수 API 서버**로 역할을 변경합니다. 새로운 poc-front(React) 애플리케이션이 react-oidc-context 라이브러리를 통해 Keycloak과의 OIDC 인증을 직접 처리합니다.

### **2\. 아키텍처 변경 사항**

#### **AS-IS (기존 구조)**

1. 사용자가 portal-frontend에서 로그인 버튼 클릭.  
2. portal-backend의 /api/login으로 리디렉션.  
3. 백엔드가 OIDC 인증 절차(Keycloak 연동)를 모두 처리.  
4. 백엔드가 OIDC 토큰을 기반으로 자체 JWT 토큰을 생성하여 쿠키에 저장.  
5. 프론트엔드는 백엔드가 발급한 JWT를 사용하여 인증 상태 유지 및 API 호출.

#### **TO-BE (신규 구조)**

1. 사용자가 poc-front에서 react-oidc-context를 통해 Keycloak으로 로그인.  
2. 로그인 성공 후, 프론트엔드는 Keycloak으로부터 **OIDC Access Token**을 직접 수신하여 상태로 관리.  
3. 프론트엔드가 백엔드 API(예: /api/launch-console)를 호출할 때, **HTTP Authorization 헤더**에 OIDC Access Token을 Bearer 타입으로 담아 전송.  
4. portal-backend는 이 토큰의 유효성을 검증하고, \*\*토큰 교환(Token Exchange)\*\*을 통해 Kubernetes API 접근용 토큰을 획득.  
5. 획득한 토큰을 사용하여 Kubernetes 리소스를 생성/관리하고 결과를 프론트엔드에 반환.

*\[새로운 인증 흐름 다이어그램 이미지\]*

### **3\. AI 에이전트 작업 요구사항**

#### **portal-backend (Go) 수정 사항**

##### **Phase 1: API 및 인증 로직 수정**

1. **internal/handlers/console.go의 HandleLaunchConsole 함수 수정**  
   * 기존의 authHandler.GetSession(c)를 통한 세션 기반 사용자 정보 조회를 제거합니다.  
   * HTTP 요청의 Authorization 헤더에서 Bearer 토큰(OIDC Access Token)을 추출하는 로직을 추가합니다.  
   * 추출한 OIDC Access Token의 유효성을 oidcProvider.VerifyIDToken을 사용하여 검증합니다.  
   * 검증된 토큰의 클레임에서 userID (preferred\_username)와 groups 정보를 추출합니다.  
   * auth.ExchangeTokenForKubernetes 함수를 호출하여, 프론트엔드로부터 받은 OIDC Access Token을 Kubernetes API 서버용 Access Token으로 **교환**합니다.  
   * 교환하여 새로 발급받은 Kubernetes용 토큰을 사용하여 k8sClient.CreateConsoleResources 함수를 호출합니다.  
2. **main.go 수정**  
   * /api/launch-console, /api/console/list, /api/console/:resourceId 등 기존 API 라우트들은 유지하되, 이들을 보호하기 위한 새로운 인증 미들웨어를 적용합니다. 이 미들웨어는 Authorization 헤더의 Bearer 토큰을 검증하는 역할을 수행해야 합니다.

##### **Phase 2: 불필요한 코드 제거**

1. **라우트 제거**: main.go에서 다음의 라우트를 **제거**합니다.  
   * api.GET("/login", ...)  
   * api.GET("/callback", ...)  
   * api.GET("/user", ...)  
   * api.POST("/logout", ...)  
2. **핸들러 및 내부 로직 제거**:  
   * internal/handlers/auth.go 파일의 내용 대부분이 불필요해지므로, HandleLogin, HandleCallback, HandleGetUser, HandleLogout 함수와 관련 로직을 **삭제**합니다. (AuthHandler 구조체는 OIDC Provider 참조를 위해 유지될 수 있습니다.)  
   * 백엔드는 더 이상 자체 세션을 관리하지 않으므로 internal/auth/session\_store.go 파일을 **삭제**합니다.  
   * 백엔드는 더 이상 자체 JWT를 발급하지 않으므로 internal/auth/jwt.go 파일을 **삭제**합니다.  
3. **미들웨어 정리**: main.go에서 기존의 세션 및 UserID 설정 관련 미들웨어(middleware.SetUserIDMiddleware)를 제거하고, 새로운 토큰 검증 미들웨어로 대체합니다.

#### **poc-front (React) 수정 사항**

1. **src/components/Dashboard.tsx 수정**  
   * "Secure Web Terminal" 메뉴 버튼 클릭 시 실행될 이벤트 핸들러를 구현합니다.  
   * 이 핸들러는 react-oidc-context의 useAuth 훅을 통해 현재 사용자의 access\_token을 가져옵니다.  
   * fetch 또는 axios를 사용하여 백엔드의 /api/launch-console 엔드포인트로 GET 요청을 보냅니다.  
   * 요청 시 **HTTP Authorization 헤더**에 Bearer ${access\_token} 형식으로 토큰을 포함시킵니다.  
   * 백엔드로부터 성공적으로 응답을 받으면, 반환된 url을 새 탭에서 엽니다.

### **4\. API 명세 (TO-BE)**

#### **웹 콘솔 실행**

* **Endpoint**: GET /api/console/launch (또는 /api/launch-console)  
* **Method**: GET  
* **Headers**:  
  * Authorization: Bearer \<OIDC\_ACCESS\_TOKEN\>  
* **Success Response (200 OK)**:  
  {  
    "success": true,  
    "message": "Web console created successfully",  
    "data": {  
      "url": "\[https://console.example.com/user-id/unique-session-id\](https://console.example.com/user-id/unique-session-id)",  
      "resource\_id": "unique-session-id"  
    }  
  }

* **Error Response (401 Unauthorized)**:  
  {  
    "error": {  
      "type": "AUTHENTICATION\_ERROR",  
      "code": "AUTH003",  
      "message": "Invalid authentication token"  
    },  
    "timestamp": "...",  
    "path": "/api/console/launch",  
    "request\_id": "..."  
  }

### **5\. 완료 조건 (Acceptance Criteria)**

1. portal-backend에서 자체 JWT 발급 및 세션 관리 코드가 모두 제거됩니다.  
2. poc-front에서 로그인하면 Keycloak의 OIDC Access Token이 정상적으로 수신됩니다.  
3. poc-front에서 "Secure Web Terminal" 버튼을 클릭하면, Authorization 헤더에 토큰을 담아 백엔드 API를 호출합니다.  
4. portal-backend는 수신한 토큰을 검증하고, Kubernetes용 토큰으로 성공적으로 교환(Token Exchange)합니다.  
5. 교환된 토큰을 사용하여 Kubernetes 위에 웹 콘솔 Pod가 정상적으로 생성되고, 프론트엔드는 접속 URL을 받아 새 탭을 엽니다.  
6. 기존의 portal-frontend는 더 이상 사용되지 않으며, poc-front가 이를 완전히 대체합니다.